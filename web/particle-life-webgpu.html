<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Life - WebGPU (Zig + GPU Compute)</title>
    <style>
        html, body {
            margin: 0 !important;
            padding: 0 !important;
            overflow: hidden;
        }
        
        body {
            font-family: monospace;
            background: #000;
        }
        
        #mainCanvas {
            position: fixed;
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        .panel {
            background-color: rgba(50, 50, 50, 0.5);
            border-radius: 12px;
            border: 2px solid #eee;
            color: #eee;
            padding: 18px;
            backdrop-filter: blur(4px);
            font-family: monospace;
            font-size: 14px;
        }
        
        #toolsPanel {
            position: fixed;
            left: 24px;
            top: 24px;
            min-width: 280px;
            opacity: 1;
            transition: opacity 0.3s;
        }
        
        #debugPanel {
            position: fixed;
            right: 24px;
            top: 24px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s;
        }
        
        #debugInfo {
            white-space: pre;
        }
        
        #copyright {
            position: fixed;
            left: 12px;
            bottom: 12px;
            color: #bbb;
            font-family: monospace;
            font-size: 14px;
        }
        
        a {
            color: #bbb;
            text-decoration: none;
        }
        
        a:hover {
            color: #eee;
            text-decoration: underline;
        }
        
        .sliderContainer {
            margin-bottom: 8px;
        }
        
        .sliderContainer input {
            width: 100%;
            margin-bottom: 4px;
        }
        
        .button {
            background-color: #777;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            cursor: pointer;
            margin-bottom: 4px;
        }
        
        .button:hover {
            background-color: #555;
        }
        
        .button:active {
            background-color: #444;
        }
        
        label {
            font-size: 12px;
            color: #eee;
        }
        
        .checkboxContainer {
            display: block;
            position: relative;
            cursor: pointer;
            padding-left: 28px;
            padding-top: 8px;
            padding-bottom: 8px;
            user-select: none;
        }
        
        .checkboxContainer input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }
        
        .customCheckbox {
            position: absolute;
            top: 8px;
            left: 0px;
            height: 20px;
            width: 20px;
            background-color: #eee;
            border-radius: 4px;
        }
        
        .checkboxContainer:hover input ~ .customCheckbox {
            background-color: #999;
        }
        
        .checkboxContainer input:checked ~ .customCheckbox {
            background-color: #777;
        }
        
        .checkboxContainer input:checked ~ .customCheckbox:after {
            display: block;
        }
        
        .customCheckbox:after {
            content: "";
            position: absolute;
            display: none;
            left: 6px;
            top: 2px;
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 3px 3px 0;
            transform: rotate(45deg);
        }
        
        table {
            table-layout: fixed;
            border: none;
            border-collapse: collapse;
            width: 100%;
        }
        
        table td {
            padding: 2px;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #4CAF50;
            text-align: center;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <canvas id="mainCanvas"></canvas>
    
    <div id="loading">
        <div>Initializing WebGPU...</div>
        <div style="font-size: 14px; margin-top: 10px; color: #888;">Please wait</div>
    </div>
    
    <div id="copyright">
        Zig + WebGPU | Based on <a href="https://lisyarus.github.io/blog/programming/2023/02/21/particle-life.html" target="_blank">@lisyarus</a> demo
    </div>
    
    <div id="toolsPanel" class="panel hidden">
        <div class="sliderContainer">
            <input type="range" min="10" max="20" value="14" class="slider" id="particleCountSlider">
            <span id="particleCountText">16384 particles</span>
        </div>
        
        <div class="sliderContainer">
            <input type="range" min="1" max="20" value="6" class="slider" id="speciesCountSlider">
            <span id="speciesCountText">6 particle types</span>
        </div>
        
        <div class="sliderContainer">
            <input type="range" min="1" max="50" value="16" class="slider" id="simulationWidthSlider">
            <span id="simulationWidthText">Width: 1024</span>
        </div>
        
        <div class="sliderContainer">
            <input type="range" min="1" max="50" value="9" class="slider" id="simulationHeightSlider">
            <span id="simulationHeightText">Height: 576</span>
        </div>
        
        <div class="sliderContainer">
            <input type="range" min="0" max="100" value="10" class="slider" id="frictionSlider">
            <span id="frictionText">Friction: 10</span>
        </div>
        
        <div class="sliderContainer">
            <input type="range" min="0" max="100" value="0" class="slider" id="centralForceSlider">
            <span id="centralForceText">Central force: 0</span>
        </div>
        
        <label class="checkboxContainer">
            Symmetric forces
            <input type="checkbox" id="symmetricForces" />
            <span class="customCheckbox"></span>
        </label>
        
        <label class="checkboxContainer">
            Looping borders
            <input type="checkbox" id="loopingBorders" />
            <span class="customCheckbox"></span>
        </label>
        
        <table id="buttonsTable">
            <tr>
                <td><div class="button" id="pauseButton">Pause</div></td>
                <td><div class="button" id="centerViewButton">Center view</div></td>
            </tr>
            <tr>
                <td><div class="button" id="restartButton">Restart</div></td>
                <td><div class="button" id="randomizeButton">Randomize</div></td>
            </tr>
        </table>
        
        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #555; font-size: 11px; color: #888;">
            <div>[S] or three-tap to hide this menu</div>
            <div>LMB or double-tap to interact</div>
            <div>[D] for debug panel</div>
        </div>
    </div>
    
    <div id="debugPanel" class="panel">
        <div id="debugInfo">Debug info</div>
    </div>

    <script>
// ============================================================================
// WGSL Shaders (from Nikita demo)
// ============================================================================

const particleDescription = `
struct Particle {
    x: f32,
    y: f32,
    vx: f32,
    vy: f32,
    species: f32,
}
`;

const speciesDescription = `
struct Species {
    color: vec4f,
}
`;

const forceDescription = `
struct Force {
    strength: f32,
    radius: f32,
    collisionStrength: f32,
    collisionRadius: f32,
}
`;

const simulationOptionsDescription = `
struct SimulationOptions {
    left: f32,
    right: f32,
    bottom: f32,
    top: f32,
    friction: f32,
    dt: f32,
    binSize: f32,
    speciesCount: f32,
    centralForce: f32,
    loopingBorders: f32,
    actionX: f32,
    actionY: f32,
    actionVX: f32,
    actionVY: f32,
    actionForce: f32,
    actionRadius: f32,
}

struct BinInfo {
    gridSize: vec2i,
    binId: vec2i,
    binIndex: i32,
}

fn getBinInfo(position: vec2f, simulationOptions: SimulationOptions) -> BinInfo {
    let gridSize = vec2i(
        i32(ceil((simulationOptions.right - simulationOptions.left) / simulationOptions.binSize)),
        i32(ceil((simulationOptions.top - simulationOptions.bottom) / simulationOptions.binSize)),
    );

    let binId = vec2i(
        clamp(i32(floor((position.x - simulationOptions.left) / simulationOptions.binSize)), 0, gridSize.x - 1),
        clamp(i32(floor((position.y - simulationOptions.bottom) / simulationOptions.binSize)), 0, gridSize.y - 1)
    );

    let binIndex = binId.y * gridSize.x + binId.x;

    return BinInfo(gridSize, binId, binIndex);
}
`;

const binFillSizeShader = `
${particleDescription}
${simulationOptionsDescription}

@group(0) @binding(0) var<storage, read> particles: array<Particle>;
@group(1) @binding(0) var<uniform> simulationOptions: SimulationOptions;
@group(2) @binding(0) var<storage, read_write> binSize: array<atomic<u32>>;

@compute @workgroup_size(64)
fn clearBinSize(@builtin(global_invocation_id) id: vec3u) {
    if (id.x >= arrayLength(&binSize)) {
        return;
    }
    atomicStore(&binSize[id.x], 0u);
}

@compute @workgroup_size(64)
fn fillBinSize(@builtin(global_invocation_id) id: vec3u) {
    if (id.x >= arrayLength(&particles)) {
        return;
    }
    let particle = particles[id.x];
    let binIndex = getBinInfo(vec2f(particle.x, particle.y), simulationOptions).binIndex;
    atomicAdd(&binSize[binIndex + 1], 1u);
}
`;

const binPrefixSumShader = `
@group(0) @binding(0) var<storage, read> source: array<u32>;
@group(0) @binding(1) var<storage, read_write> destination: array<u32>;
@group(0) @binding(2) var<uniform> stepSize: u32;

@compute @workgroup_size(64)
fn prefixSumStep(@builtin(global_invocation_id) id: vec3u) {
    if (id.x >= arrayLength(&source)) {
        return;
    }
    if (id.x < stepSize) {
        destination[id.x] = source[id.x];
    } else {
        destination[id.x] = source[id.x - stepSize] + source[id.x];
    }
}
`;

const particleSortShader = `
${particleDescription}
${simulationOptionsDescription}

@group(0) @binding(0) var<storage, read> source: array<Particle>;
@group(0) @binding(1) var<storage, read_write> destination: array<Particle>;
@group(0) @binding(2) var<storage, read> binOffset: array<u32>;
@group(0) @binding(3) var<storage, read_write> binSize: array<atomic<u32>>;
@group(1) @binding(0) var<uniform> simulationOptions: SimulationOptions;

@compute @workgroup_size(64)
fn clearBinSize(@builtin(global_invocation_id) id: vec3u) {
    if (id.x >= arrayLength(&binSize)) {
        return;
    }
    atomicStore(&binSize[id.x], 0u);
}

@compute @workgroup_size(64)
fn sortParticles(@builtin(global_invocation_id) id: vec3u) {
    if (id.x >= arrayLength(&source)) {
        return;
    }
    let particle = source[id.x];
    let binIndex = getBinInfo(vec2f(particle.x, particle.y), simulationOptions).binIndex;
    let newParticleIndex = binOffset[binIndex] + atomicAdd(&binSize[binIndex], 1);
    destination[newParticleIndex] = particle;
}
`;

const particleComputeForcesShader = `
${particleDescription}
${forceDescription}
${simulationOptionsDescription}

@group(0) @binding(0) var<storage, read> particlesSource: array<Particle>;
@group(0) @binding(1) var<storage, read_write> particlesDestination: array<Particle>;
@group(0) @binding(2) var<storage, read> binOffset: array<u32>;
@group(0) @binding(3) var<storage, read> forces: array<Force>;
@group(1) @binding(0) var<uniform> simulationOptions: SimulationOptions;

@compute @workgroup_size(64)
fn computeForces(@builtin(global_invocation_id) id: vec3u) {
    if (id.x >= arrayLength(&particlesSource)) {
        return;
    }

    var particle = particlesSource[id.x];
    let species = u32(particle.species);
    let binInfo = getBinInfo(vec2f(particle.x, particle.y), simulationOptions);
    let loopingBorders = simulationOptions.loopingBorders == 1.0;

    var binXMin = binInfo.binId.x - 1;
    var binYMin = binInfo.binId.y - 1;
    var binXMax = binInfo.binId.x + 1;
    var binYMax = binInfo.binId.y + 1;

    if (!loopingBorders) {
        binXMin = max(0, binXMin);
        binYMin = max(0, binYMin);
        binXMax = min(binInfo.gridSize.x - 1, binXMax);
        binYMax = min(binInfo.gridSize.y - 1, binYMax);
    }

    let width = simulationOptions.right - simulationOptions.left;
    let height = simulationOptions.top - simulationOptions.bottom;
    var totalForce = vec2f(0.0, 0.0);
    let particlePosition = vec2f(particle.x, particle.y);

    totalForce -= particlePosition * simulationOptions.centralForce;

    for (var binX = binXMin; binX <= binXMax; binX += 1) {
        for (var binY = binYMin; binY <= binYMax; binY += 1) {
            var realBinX = (binX + binInfo.gridSize.x) % binInfo.gridSize.x;
            var realBinY = (binY + binInfo.gridSize.y) % binInfo.gridSize.y;

            let binIndex = realBinY * binInfo.gridSize.x + realBinX;
            let binStart = binOffset[binIndex];
            let binEnd = binOffset[binIndex + 1];

            for (var j = binStart; j < binEnd; j += 1) {
                if (j == id.x) {
                    continue;
                }

                let other = particlesSource[j];
                let otherSpecies = u32(other.species);
                let force = forces[species * u32(simulationOptions.speciesCount) + otherSpecies];

                var r = vec2f(other.x, other.y) - particlePosition;

                if (loopingBorders) {
                    if (abs(r.x) >= width * 0.5) {
                        r.x -= sign(r.x) * width;
                    }
                    if (abs(r.y) >= height * 0.5) {
                        r.y -= sign(r.y) * height;
                    }
                }

                let d = length(r);
                if (d > 0.0 && d < force.radius) {
                    let n = r / d;
                    totalForce += force.strength * max(0.0, 1.0 - d / force.radius) * n;
                    totalForce -= force.collisionStrength * max(0.0, 1.0 - d / force.collisionRadius) * n;
                }
            }
        }
    }

    particle.vx += totalForce.x * simulationOptions.dt;
    particle.vy += totalForce.y * simulationOptions.dt;
    particlesDestination[id.x] = particle;
}
`;

const particleAdvanceShader = `
${particleDescription}
${simulationOptionsDescription}

@group(0) @binding(0) var<storage, read_write> particles: array<Particle>;
@group(1) @binding(0) var<uniform> simulationOptions: SimulationOptions;

@compute @workgroup_size(64)
fn particleAdvance(@builtin(global_invocation_id) id: vec3u) {
    if (id.x >= arrayLength(&particles)) {
        return;
    }

    let width = simulationOptions.right - simulationOptions.left;
    let height = simulationOptions.top - simulationOptions.bottom;
    var particle = particles[id.x];

    var actionR = vec2f(particle.x, particle.y) - vec2f(simulationOptions.actionX, simulationOptions.actionY);
    if (simulationOptions.loopingBorders == 1.0) {
        if (abs(actionR.x) >= width * 0.5) {
            actionR.x -= sign(actionR.x) * width;
        }
        if (abs(actionR.y) >= height * 0.5) {
            actionR.y -= sign(actionR.y) * height;
        }
    }
    let actionFactor = simulationOptions.actionForce * exp(- dot(actionR, actionR) / (simulationOptions.actionRadius * simulationOptions.actionRadius));
    particle.vx += simulationOptions.actionVX * actionFactor;
    particle.vy += simulationOptions.actionVY * actionFactor;

    particle.vx *= simulationOptions.friction;
    particle.vy *= simulationOptions.friction;
    particle.x += particle.vx * simulationOptions.dt;
    particle.y += particle.vy * simulationOptions.dt;

    let loopingBorders = simulationOptions.loopingBorders == 1.0;

    if (loopingBorders) {
        if (particle.x < simulationOptions.left) {
            particle.x += width;
        }
        if (particle.x > simulationOptions.right) {
            particle.x -= width;
        }
        if (particle.y < simulationOptions.bottom) {
            particle.y += height;
        }
        if (particle.y > simulationOptions.top) {
            particle.y -= height;
        }
    } else {
        if (particle.x < simulationOptions.left) {
            particle.x = simulationOptions.left;
            particle.vx *= -1.0;
        }
        if (particle.x > simulationOptions.right) {
            particle.x = simulationOptions.right;
            particle.vx *= -1.0;
        }
        if (particle.y < simulationOptions.bottom) {
            particle.y = simulationOptions.bottom;
            particle.vy *= -1.0;
        }
        if (particle.y > simulationOptions.top) {
            particle.y = simulationOptions.top;
            particle.vy *= -1.0;
        }
    }

    particles[id.x] = particle;
}
`;

const particleRenderShader = `
${particleDescription}
${speciesDescription}

struct Camera {
    center: vec2f,
    extent: vec2f,
    pixelsPerUnit: f32,
}

@group(0) @binding(0) var<storage, read> particles: array<Particle>;
@group(0) @binding(1) var<storage, read> species: array<Species>;
@group(1) @binding(0) var<uniform> camera: Camera;

struct CircleVertexOut {
    @builtin(position) position: vec4f,
    @location(0) offset: vec2f,
    @location(1) color: vec4f,
}

const offsets = array<vec2f, 6>(
    vec2f(-1.0, -1.0),
    vec2f( 1.0, -1.0),
    vec2f(-1.0,  1.0),
    vec2f(-1.0,  1.0),
    vec2f( 1.0, -1.0),
    vec2f( 1.0,  1.0),
);

@vertex
fn vertexGlow(@builtin(vertex_index) id: u32) -> CircleVertexOut {
    let particle = particles[id / 6u];
    let offset = offsets[id % 6u];
    let position = vec2f(particle.x, particle.y) + 12.0 * offset;
    return CircleVertexOut(
        vec4f((position - camera.center) / camera.extent, 0.0, 1.0),
        offset,
        species[u32(particle.species)].color
    );
}

@fragment
fn fragmentGlow(in: CircleVertexOut) -> @location(0) vec4f {
    let l = length(in.offset);
    let alpha = exp(- 6.0 * l * l) / 64.0;
    return in.color * vec4f(1.0, 1.0, 1.0, alpha);
}

@vertex
fn vertexCircle(@builtin(vertex_index) id: u32) -> CircleVertexOut {
    let particle = particles[id / 6u];
    let offset = offsets[id % 6u] * 1.5;
    let position = vec2f(particle.x, particle.y) + offset;
    return CircleVertexOut(
        vec4f((position - camera.center) / camera.extent, 0.0, 1.0),
        offset,
        species[u32(particle.species)].color
    );
}

@fragment
fn fragmentCircle(in: CircleVertexOut) -> @location(0) vec4f {
    let alpha = clamp(camera.pixelsPerUnit - length(in.offset) * camera.pixelsPerUnit + 0.5, 0.0, 1.0);
    return in.color * vec4f(1.0, 1.0, 1.0, alpha);
}

@vertex
fn vertexPoint(@builtin(vertex_index) id: u32) -> CircleVertexOut {
    let particle = particles[id / 6u];
    let offset = 2.0 * offsets[id % 6u] / camera.pixelsPerUnit;
    let position = vec2f(particle.x, particle.y) + offset;
    return CircleVertexOut(
        vec4f((position - camera.center) / camera.extent, 0.0, 1.0),
        offset,
        species[u32(particle.species)].color
    );
}

const PI = 3.1415926535;

@fragment
fn fragmentPoint(in: CircleVertexOut) -> @location(0) vec4f {
    let d = max(vec2(0.0), min(in.offset * camera.pixelsPerUnit + 0.5, vec2(camera.pixelsPerUnit)) - max(in.offset * camera.pixelsPerUnit - 0.5, - vec2(camera.pixelsPerUnit)));
    let alpha = (PI / 4.0) * d.x * d.y;
    return vec4f(in.color.rgb, in.color.a * alpha);
}
`;

const composeShader = `
@group(0) @binding(0) var hdrTexture: texture_2d<f32>;
@group(0) @binding(1) var blueNoiseTexture: texture_2d<f32>;

const vertices = array<vec2f, 3>(
    vec2f(-1.0, -1.0),
    vec2f( 3.0, -1.0),
    vec2f(-1.0,  3.0),
);

struct VertexOut {
    @builtin(position) position: vec4f,
    @location(0) texcoord: vec2f,
}

@vertex
fn vertexMain(@builtin(vertex_index) id: u32) -> VertexOut {
    let vertex = vertices[id];
    return VertexOut(
        vec4f(vertex, 0.0, 1.0),
        vertex * 0.5 + vec2f(0.5)
    );
}

fn acesTonemap(x: vec3f) -> vec3f {
    let a = 2.51;
    let b = 0.03;
    let c = 2.43;
    let d = 0.59;
    let e = 0.14;
    return clamp((x*(a*x+b))/(x*(c*x+d)+e), vec3f(0.0), vec3f(1.0));
}

fn dither(x: vec3f, n: f32) -> vec3f {
    let c = x * 255.0;
    let c0 = floor(c);
    let c1 = c0 + vec3f(1.0);
    let dc = c - c0;

    var r = c0;
    if (dc.r > n) { r.r = c1.r; }
    if (dc.g > n) { r.g = c1.g; }
    if (dc.b > n) { r.b = c1.b; }

    return r / 255.0;
}

@fragment
fn fragmentMain(in: VertexOut) -> @location(0) vec4f {
    var sample = textureLoad(hdrTexture, vec2i(in.position.xy), 0); 
    let noise = textureLoad(blueNoiseTexture, vec2u(in.position.xy) % textureDimensions(blueNoiseTexture), 0).r;

    var color = sample.rgb;
    color = acesTonemap(color);
    color = pow(color, vec3f(1.0 / 2.2));
    color = dither(color, noise);

    return vec4f(color, 1.0);
}
`;

// ============================================================================
// WebGPU Implementation
// ============================================================================

let canvas, context, surfaceFormat, device;
let particleCount = 16384;
let speciesCount = 6;
let simulationBox = [[-512, 512], [-288, 288]];
let friction = 10.0;
let centralForce = 0.0;
let symmetricForces = false;
let loopingBorders = false;
let paused = false;
let toolsPanelShown = true;
let debugPanelShown = false;

const maxForceRadius = 32.0;
const maxForceStrength = 100.0;
const initialVelocity = 10.0;
const hdrFormat = 'rgba16float';

// Buffers
let speciesBuffer, forcesBuffer, particleBuffer, particleTempBuffer;
let binOffsetBuffer, binOffsetTempBuffer, binPrefixSumStepSizeBuffer;
let cameraBuffer, simulationOptionsBuffer;

// Textures
let blueNoiseTexture, blueNoiseTextureView;
let hdrTexture, hdrTextureView;

// Pipelines
let binClearSizePipeline, binFillSizePipeline, binPrefixSumPipeline;
let particleSortClearSizePipeline, particleSortPipeline;
let particleComputeForcesPipeline, particleAdvancePipeline;
let particleRenderGlowPipeline, particleRenderPipeline, particleRenderPointPipeline;
let composePipeline;

// Bind groups
let particleBufferBindGroup, particleBufferReadOnlyBindGroup;
let binFillSizeBindGroup, binPrefixSumBindGroup = [null, null];
let particleSortBindGroup, particleComputeForcesBindGroup;
let cameraBindGroup, simulationOptionsBindGroup, composeBindGroup;

// Camera
let cameraCenter = [0.0, 0.0];
let cameraExtentX = simulationBox[0][1];
let cameraExtentY = simulationBox[1][1];
let cameraExtentXTarget = simulationBox[0][1];
let zoomAnchor = null;

// Mouse/Touch
let mouseDrag = null;
let actionPoint = null;
let actionDrag = null;

// Animation
let lastFrameTimestamp = performance.now() / 1000.0;
let frameID = 0;

// Grid
let gridSize, binCount, prefixSumIterations;

// Random number generator (SplitMix32)
function splitmix32(seed) {
    return function() {
        seed |= 0;
        seed = seed + 0x9e3779b9 | 0;
        let t = seed ^ seed >>> 16;
        t = Math.imul(t, 0x21f0aaad);
        t = t ^ t >>> 15;
        t = Math.imul(t, 0x735a2d97);
        return ((t = t ^ t >>> 15) >>> 0) / 4294967296;
    }
}

function randomSeed() {
    return (Math.random() * (2 ** 32)) >>> 0;
}

// ============================================================================
// System Generation
// ============================================================================

function generateSystem(seed) {
    const rng = splitmix32(seed);
    
    // Generate species colors
    const species = new Float32Array(speciesCount * 4);
    for (let i = 0; i < speciesCount; i++) {
        const r = Math.pow(0.25 + rng() * 0.75, 2.2);
        const g = Math.pow(0.25 + rng() * 0.75, 2.2);
        const b = Math.pow(0.25 + rng() * 0.75, 2.2);
        species[4 * i + 0] = r;
        species[4 * i + 1] = g;
        species[4 * i + 2] = b;
        species[4 * i + 3] = 1.0;
    }
    
    // Generate forces
    const forces = new Float32Array(speciesCount * speciesCount * 4);
    for (let i = 0; i < speciesCount; i++) {
        for (let j = 0; j < speciesCount; j++) {
            const idx = i * speciesCount + j;
            const strength = maxForceStrength * (0.25 + 0.75 * rng()) * (rng() < 0.5 ? 1.0 : -1.0);
            const collisionStrength = (5.0 + 15.0 * rng()) * Math.abs(strength);
            const radius = 2.0 + rng() * (maxForceRadius - 2.0);
            const collisionRadius = rng() * 0.5 * radius;
            
            forces[4 * idx + 0] = strength;
            forces[4 * idx + 1] = radius;
            forces[4 * idx + 2] = collisionStrength;
            forces[4 * idx + 3] = collisionRadius;
        }
    }
    
    // Symmetrize if needed
    if (symmetricForces) {
        for (let i = 0; i < speciesCount; i++) {
            for (let j = i + 1; j < speciesCount; j++) {
                const idx_ij = i * speciesCount + j;
                const idx_ji = j * speciesCount + i;
                
                const strength = (forces[4 * idx_ij + 0] + forces[4 * idx_ji + 0]) / 2.0;
                const radius = (forces[4 * idx_ij + 1] + forces[4 * idx_ji + 1]) / 2.0;
                const collisionStrength = (forces[4 * idx_ij + 2] + forces[4 * idx_ji + 2]) / 2.0;
                const collisionRadius = (forces[4 * idx_ij + 3] + forces[4 * idx_ji + 3]) / 2.0;
                
                forces[4 * idx_ij + 0] = forces[4 * idx_ji + 0] = strength;
                forces[4 * idx_ij + 1] = forces[4 * idx_ji + 1] = radius;
                forces[4 * idx_ij + 2] = forces[4 * idx_ji + 2] = collisionStrength;
                forces[4 * idx_ij + 3] = forces[4 * idx_ji + 3] = collisionRadius;
            }
        }
    }
    
    // Generate particles
    const particles = new Float32Array(particleCount * 5);
    const width = simulationBox[0][1] - simulationBox[0][0];
    const height = simulationBox[1][1] - simulationBox[1][0];
    
    for (let i = 0; i < particleCount; i++) {
        particles[5 * i + 0] = simulationBox[0][0] + rng() * width;
        particles[5 * i + 1] = simulationBox[1][0] + rng() * height;
        particles[5 * i + 2] = initialVelocity * (-1.0 + rng() * 2.0);
        particles[5 * i + 3] = initialVelocity * (-1.0 + rng() * 2.0);
        particles[5 * i + 4] = Math.floor(rng() * speciesCount);
    }
    
    return { species, forces, particles };
}

// ============================================================================
// WebGPU Setup
// ============================================================================

async function loadImage(url) {
    const res = await fetch(url);
    const blob = await res.blob();
    return await createImageBitmap(blob, { colorSpaceConversion: 'none' });
}

function updateGridSize() {
    gridSize = [
        Math.ceil((simulationBox[0][1] - simulationBox[0][0]) / maxForceRadius),
        Math.ceil((simulationBox[1][1] - simulationBox[1][0]) / maxForceRadius)
    ];
    binCount = gridSize[0] * gridSize[1];
    prefixSumIterations = Math.ceil(Math.ceil(Math.log2(binCount + 1)) / 2) * 2;
}

function loadSystem(systemData) {
    // Upload species data
    device.queue.writeBuffer(speciesBuffer, 0, systemData.species);
    
    // Upload forces data
    device.queue.writeBuffer(forcesBuffer, 0, systemData.forces);
    
    // Upload particles data
    device.queue.writeBuffer(particleBuffer, 0, systemData.particles);
}

function centerView() {
    cameraCenter = [0.0, 0.0];
    zoomAnchor = null;
    
    const aspectRatio = canvas.width / canvas.height;
    const simWidth = simulationBox[0][1] - simulationBox[0][0];
    const simHeight = simulationBox[1][1] - simulationBox[1][0];
    
    if (simWidth / simHeight > aspectRatio) {
        cameraExtentXTarget = simulationBox[0][1];
    } else {
        cameraExtentXTarget = simulationBox[1][1] * aspectRatio;
    }
}

async function initWebGPU() {
    if (!navigator.gpu) {
        alert('WebGPU is not supported in your browser!');
        return false;
    }
    
    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) {
        alert('Failed to get GPU adapter!');
        return false;
    }
    
    device = await adapter.requestDevice();
    if (!device) {
        alert('Failed to get GPU device!');
        return false;
    }
    
    canvas = document.getElementById('mainCanvas');
    context = canvas.getContext('webgpu');
    surfaceFormat = navigator.gpu.getPreferredCanvasFormat();
    
    context.configure({
        device,
        format: surfaceFormat,
    });
    
    return true;
}

async function initResources() {
    updateGridSize();
    
    // Create buffers
    speciesBuffer = device.createBuffer({
        size: speciesCount * 16,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,
    });
    
    forcesBuffer = device.createBuffer({
        size: speciesCount * speciesCount * 16,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE,
    });
    
    particleBuffer = device.createBuffer({
        size: particleCount * 20,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE,
    });
    
    particleTempBuffer = device.createBuffer({
        size: particleCount * 20,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
    
    binOffsetBuffer = device.createBuffer({
        size: (binCount + 1) * 4,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
    });
    
    binOffsetTempBuffer = device.createBuffer({
        size: (binCount + 1) * 4,
        usage: GPUBufferUsage.STORAGE,
    });
    
    const binPrefixSumStepSize = new Uint32Array(prefixSumIterations * 64);
    for (let i = 0; i < prefixSumIterations; i++) {
        binPrefixSumStepSize[i * 64] = Math.pow(2, i);
    }
    
    binPrefixSumStepSizeBuffer = device.createBuffer({
        size: prefixSumIterations * 256,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
    });
    device.queue.writeBuffer(binPrefixSumStepSizeBuffer, 0, binPrefixSumStepSize);
    
    cameraBuffer = device.createBuffer({
        size: 24,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
    });
    
    simulationOptionsBuffer = device.createBuffer({
        size: 64,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
    });
    
    // Load blue noise texture
    const blueNoiseImage = await loadImage('blue-noise.png');
    blueNoiseTexture = device.createTexture({
        format: 'rgba8unorm-srgb',
        size: [blueNoiseImage.width, blueNoiseImage.height],
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
    });
    device.queue.copyExternalImageToTexture(
        { source: blueNoiseImage },
        { texture: blueNoiseTexture },
        { width: blueNoiseImage.width, height: blueNoiseImage.height },
    );
    blueNoiseTextureView = blueNoiseTexture.createView();
}

function createPipelines() {
    // Shader modules
    const binFillSizeModule = device.createShaderModule({ code: binFillSizeShader });
    const binPrefixSumModule = device.createShaderModule({ code: binPrefixSumShader });
    const particleSortModule = device.createShaderModule({ code: particleSortShader });
    const particleComputeForcesModule = device.createShaderModule({ code: particleComputeForcesShader });
    const particleAdvanceModule = device.createShaderModule({ code: particleAdvanceShader });
    const particleRenderModule = device.createShaderModule({ code: particleRenderShader });
    const composeModule = device.createShaderModule({ code: composeShader });
    
    // Bind group layouts
    const particleBufferBindGroupLayout = device.createBindGroupLayout({
        entries: [
            { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
            { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        ],
    });
    
    const particleBufferReadOnlyBindGroupLayout = device.createBindGroupLayout({
        entries: [
            { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
            { binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        ],
    });
    
    const cameraBindGroupLayout = device.createBindGroupLayout({
        entries: [
            { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: 'uniform' } },
        ],
    });
    
    const simulationOptionsBindGroupLayout = device.createBindGroupLayout({
        entries: [
            { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
        ],
    });
    
    const binFillSizeBindGroupLayout = device.createBindGroupLayout({
        entries: [
            { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
        ],
    });
    
    const binPrefixSumBindGroupLayout = device.createBindGroupLayout({
        entries: [
            { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
            { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
            { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform', hasDynamicOffset: true } },
        ],
    });
    
    const particleSortBindGroupLayout = device.createBindGroupLayout({
        entries: [
            { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
            { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
            { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
            { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
        ],
    });
    
    const particleComputeForcesBindGroupLayout = device.createBindGroupLayout({
        entries: [
            { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
            { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
            { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
            { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
        ],
    });
    
    const composeBindGroupLayout = device.createBindGroupLayout({
        entries: [
            { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
            { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        ],
    });
    
    // Create compute pipelines
    binClearSizePipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [particleBufferReadOnlyBindGroupLayout, simulationOptionsBindGroupLayout, binFillSizeBindGroupLayout],
        }),
        compute: { module: binFillSizeModule, entryPoint: 'clearBinSize' },
    });
    
    binFillSizePipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [particleBufferReadOnlyBindGroupLayout, simulationOptionsBindGroupLayout, binFillSizeBindGroupLayout],
        }),
        compute: { module: binFillSizeModule, entryPoint: 'fillBinSize' },
    });
    
    binPrefixSumPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [binPrefixSumBindGroupLayout],
        }),
        compute: { module: binPrefixSumModule, entryPoint: 'prefixSumStep' },
    });
    
    particleSortClearSizePipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [particleSortBindGroupLayout, simulationOptionsBindGroupLayout],
        }),
        compute: { module: particleSortModule, entryPoint: 'clearBinSize' },
    });
    
    particleSortPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [particleSortBindGroupLayout, simulationOptionsBindGroupLayout],
        }),
        compute: { module: particleSortModule, entryPoint: 'sortParticles' },
    });
    
    particleComputeForcesPipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [particleComputeForcesBindGroupLayout, simulationOptionsBindGroupLayout],
        }),
        compute: { module: particleComputeForcesModule, entryPoint: 'computeForces' },
    });
    
    particleAdvancePipeline = device.createComputePipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [particleBufferBindGroupLayout, simulationOptionsBindGroupLayout],
        }),
        compute: { module: particleAdvanceModule, entryPoint: 'particleAdvance' },
    });
    
    // Create render pipelines
    particleRenderGlowPipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [particleBufferReadOnlyBindGroupLayout, cameraBindGroupLayout],
        }),
        vertex: { module: particleRenderModule, entryPoint: 'vertexGlow' },
        primitive: { topology: 'triangle-list' },
        fragment: {
            module: particleRenderModule,
            entryPoint: 'fragmentGlow',
            targets: [{
                format: hdrFormat,
                blend: {
                    color: { srcFactor: 'src-alpha', dstFactor: 'one' },
                    alpha: { srcFactor: 'one', dstFactor: 'one' },
                },
            }],
        },
    });
    
    particleRenderPipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [particleBufferReadOnlyBindGroupLayout, cameraBindGroupLayout],
        }),
        vertex: { module: particleRenderModule, entryPoint: 'vertexCircle' },
        primitive: { topology: 'triangle-list' },
        fragment: {
            module: particleRenderModule,
            entryPoint: 'fragmentCircle',
            targets: [{
                format: hdrFormat,
                blend: {
                    color: { srcFactor: 'src-alpha', dstFactor: 'one' },
                    alpha: { srcFactor: 'one', dstFactor: 'one' },
                },
            }],
        },
    });
    
    particleRenderPointPipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [particleBufferReadOnlyBindGroupLayout, cameraBindGroupLayout],
        }),
        vertex: { module: particleRenderModule, entryPoint: 'vertexPoint' },
        primitive: { topology: 'triangle-list' },
        fragment: {
            module: particleRenderModule,
            entryPoint: 'fragmentPoint',
            targets: [{
                format: hdrFormat,
                blend: {
                    color: { srcFactor: 'src-alpha', dstFactor: 'one' },
                    alpha: { srcFactor: 'one', dstFactor: 'one' },
                },
            }],
        },
    });
    
    composePipeline = device.createRenderPipeline({
        layout: device.createPipelineLayout({
            bindGroupLayouts: [composeBindGroupLayout],
        }),
        vertex: { module: composeModule, entryPoint: 'vertexMain' },
        primitive: { topology: 'triangle-list' },
        fragment: {
            module: composeModule,
            entryPoint: 'fragmentMain',
            targets: [{ format: surfaceFormat }],
        },
    });
    
    // Create bind groups
    particleBufferBindGroup = device.createBindGroup({
        layout: particleBufferBindGroupLayout,
        entries: [
            { binding: 0, resource: { buffer: particleBuffer } },
            { binding: 1, resource: { buffer: forcesBuffer } },
        ],
    });
    
    particleBufferReadOnlyBindGroup = device.createBindGroup({
        layout: particleBufferReadOnlyBindGroupLayout,
        entries: [
            { binding: 0, resource: { buffer: particleBuffer } },
            { binding: 1, resource: { buffer: speciesBuffer } },
        ],
    });
    
    binFillSizeBindGroup = device.createBindGroup({
        layout: binFillSizeBindGroupLayout,
        entries: [
            { binding: 0, resource: { buffer: binOffsetBuffer } },
        ],
    });
    
    binPrefixSumBindGroup[0] = device.createBindGroup({
        layout: binPrefixSumBindGroupLayout,
        entries: [
            { binding: 0, resource: { buffer: binOffsetBuffer } },
            { binding: 1, resource: { buffer: binOffsetTempBuffer } },
            { binding: 2, resource: { buffer: binPrefixSumStepSizeBuffer, size: 4 } },
        ],
    });
    
    binPrefixSumBindGroup[1] = device.createBindGroup({
        layout: binPrefixSumBindGroupLayout,
        entries: [
            { binding: 0, resource: { buffer: binOffsetTempBuffer } },
            { binding: 1, resource: { buffer: binOffsetBuffer } },
            { binding: 2, resource: { buffer: binPrefixSumStepSizeBuffer, size: 4 } },
        ],
    });
    
    particleSortBindGroup = device.createBindGroup({
        layout: particleSortBindGroupLayout,
        entries: [
            { binding: 0, resource: { buffer: particleBuffer } },
            { binding: 1, resource: { buffer: particleTempBuffer } },
            { binding: 2, resource: { buffer: binOffsetBuffer } },
            { binding: 3, resource: { buffer: binOffsetTempBuffer } },
        ],
    });
    
    particleComputeForcesBindGroup = device.createBindGroup({
        layout: particleComputeForcesBindGroupLayout,
        entries: [
            { binding: 0, resource: { buffer: particleTempBuffer } },
            { binding: 1, resource: { buffer: particleBuffer } },
            { binding: 2, resource: { buffer: binOffsetBuffer } },
            { binding: 3, resource: { buffer: forcesBuffer } },
        ],
    });
    
    cameraBindGroup = device.createBindGroup({
        layout: cameraBindGroupLayout,
        entries: [
            { binding: 0, resource: { buffer: cameraBuffer } },
        ],
    });
    
    simulationOptionsBindGroup = device.createBindGroup({
        layout: simulationOptionsBindGroupLayout,
        entries: [
            { binding: 0, resource: { buffer: simulationOptionsBuffer } },
        ],
    });
}

function resize() {
    if (!canvas) return;
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    hdrTexture = device.createTexture({
        format: hdrFormat,
        size: [canvas.width, canvas.height, 1],
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,
    });
    
    hdrTextureView = hdrTexture.createView();
    
    composeBindGroup = device.createBindGroup({
        layout: composePipeline.getBindGroupLayout(0),
        entries: [
            { binding: 0, resource: hdrTextureView },
            { binding: 1, resource: blueNoiseTextureView },
        ],
    });
}

// ============================================================================
// Main Loop
// ============================================================================

function redraw() {
    const now = performance.now() / 1000.0;
    const dt = now - lastFrameTimestamp;
    lastFrameTimestamp = now;
    
    const aspectRatio = canvas.width / canvas.height;
    const cameraExtentXDelta = (cameraExtentXTarget - cameraExtentX) * (-Math.expm1(-20 * dt));
    
    cameraExtentX += cameraExtentXDelta;
    cameraExtentY = cameraExtentX / aspectRatio;
    
    if (zoomAnchor) {
        cameraCenter[0] -= cameraExtentXDelta * zoomAnchor[0];
        cameraCenter[1] -= cameraExtentXDelta * zoomAnchor[1] / aspectRatio;
    }
    
    const pixelsPerUnit = canvas.width / (2.0 * cameraExtentX);
    
    // Update panel visibility
    const toolsPanel = document.getElementById("toolsPanel");
    let toolsPanelAlpha = Number(toolsPanel.style.opacity) || (toolsPanelShown ? 1 : 0);
    toolsPanelAlpha += ((toolsPanelShown ? 1.0 : 0.0) - toolsPanelAlpha) * (-Math.expm1(-20 * dt));
    toolsPanel.style.opacity = toolsPanelAlpha;
    toolsPanel.style.visibility = (toolsPanelAlpha < 0.01) ? "hidden" : "visible";
    
    const debugPanel = document.getElementById("debugPanel");
    let debugPanelAlpha = Number(debugPanel.style.opacity) || (debugPanelShown ? 1 : 0);
    debugPanelAlpha += ((debugPanelShown ? 1.0 : 0.0) - debugPanelAlpha) * (-Math.expm1(-20 * dt));
    debugPanel.style.opacity = debugPanelAlpha;
    debugPanel.style.visibility = (debugPanelAlpha < 0.01) ? "hidden" : "visible";
    
    const simDt = Math.min(0.025, dt);
    const frictionFactor = Math.exp(-simDt * friction);
    
    const actionX = actionPoint ? cameraCenter[0] + cameraExtentX * (2.0 * actionPoint[0] / canvas.width - 1.0) : 0.0;
    const actionY = actionPoint ? cameraCenter[1] + cameraExtentY * (1.0 - 2.0 * actionPoint[1] / canvas.height) : 0.0;
    const actionVX = actionDrag ? cameraExtentX * (2.0 * actionDrag[0] / canvas.width) : 0.0;
    const actionVY = actionDrag ? cameraExtentY * (-2.0 * actionDrag[1] / canvas.height) : 0.0;
    const actionForce = actionPoint ? 20.0 : 0.0;
    const actionRadius = cameraExtentX / 16.0;
    
    actionDrag = [0.0, 0.0];
    
    device.queue.writeBuffer(simulationOptionsBuffer, 0, new Float32Array([
        simulationBox[0][0], simulationBox[0][1], simulationBox[1][0], simulationBox[1][1],
        frictionFactor, simDt, maxForceRadius, speciesCount, centralForce,
        loopingBorders ? 1.0 : 0.0, actionX, actionY, actionVX, actionVY, actionForce, actionRadius
    ]));
    
    device.queue.writeBuffer(cameraBuffer, 0, new Float32Array([
        cameraCenter[0], cameraCenter[1], cameraExtentX, cameraExtentY, pixelsPerUnit, 0.0
    ]));
    
    const encoder = device.createCommandEncoder();
    
    if (!paused) {
        encoder.copyBufferToBuffer(particleBuffer, 0, particleTempBuffer, 0, particleBuffer.size);
        
        const binningComputePass = encoder.beginComputePass();
        binningComputePass.setBindGroup(0, particleBufferReadOnlyBindGroup);
        binningComputePass.setBindGroup(1, simulationOptionsBindGroup);
        binningComputePass.setBindGroup(2, binFillSizeBindGroup);
        binningComputePass.setPipeline(binClearSizePipeline);
        binningComputePass.dispatchWorkgroups(Math.ceil((binCount + 1) / 64));
        binningComputePass.setPipeline(binFillSizePipeline);
        binningComputePass.dispatchWorkgroups(Math.ceil(particleCount / 64));
        
        binningComputePass.setPipeline(binPrefixSumPipeline);
        for (let i = 0; i < prefixSumIterations; i++) {
            binningComputePass.setBindGroup(0, binPrefixSumBindGroup[i % 2], [i * 256]);
            binningComputePass.dispatchWorkgroups(Math.ceil((binCount + 1) / 64));
        }
        
        binningComputePass.setBindGroup(0, particleSortBindGroup);
        binningComputePass.setPipeline(particleSortClearSizePipeline);
        binningComputePass.dispatchWorkgroups(Math.ceil((binCount + 1) / 64));
        binningComputePass.setPipeline(particleSortPipeline);
        binningComputePass.dispatchWorkgroups(Math.ceil(particleCount / 64));
        binningComputePass.end();
        
        const forcesComputePass = encoder.beginComputePass();
        forcesComputePass.setBindGroup(0, particleComputeForcesBindGroup);
        forcesComputePass.setBindGroup(1, simulationOptionsBindGroup);
        forcesComputePass.setPipeline(particleComputeForcesPipeline);
        forcesComputePass.dispatchWorkgroups(Math.ceil(particleCount / 64));
        forcesComputePass.end();
        
        const advanceComputePass = encoder.beginComputePass();
        advanceComputePass.setBindGroup(0, particleBufferBindGroup);
        advanceComputePass.setBindGroup(1, simulationOptionsBindGroup);
        advanceComputePass.setPipeline(particleAdvancePipeline);
        advanceComputePass.dispatchWorkgroups(Math.ceil(particleCount / 64));
        advanceComputePass.end();
    }
    
    const hdrRenderPass = encoder.beginRenderPass({
        colorAttachments: [{
            view: hdrTextureView,
            clearValue: [0.001, 0.001, 0.001, 0.0],
            loadOp: 'clear',
            storeOp: 'store',
        }],
    });
    hdrRenderPass.setBindGroup(0, particleBufferReadOnlyBindGroup);
    hdrRenderPass.setBindGroup(1, cameraBindGroup);
    hdrRenderPass.setPipeline(particleRenderGlowPipeline);
    hdrRenderPass.draw(particleCount * 6);
    if (pixelsPerUnit < 1.0) {
        hdrRenderPass.setPipeline(particleRenderPointPipeline);
        hdrRenderPass.draw(particleCount * 6);
    } else {
        hdrRenderPass.setPipeline(particleRenderPipeline);
        hdrRenderPass.draw(particleCount * 6);
    }
    hdrRenderPass.end();
    
    const composeRenderPass = encoder.beginRenderPass({
        colorAttachments: [{
            view: context.getCurrentTexture().createView(),
            clearValue: [0, 0, 0, 0],
            loadOp: 'clear',
            storeOp: 'store',
        }],
    });
    composeRenderPass.setBindGroup(0, composeBindGroup);
    composeRenderPass.setPipeline(composePipeline);
    composeRenderPass.draw(3);
    composeRenderPass.end();
    
    device.queue.submit([encoder.finish()]);
    
    frameID++;
    requestAnimationFrame(redraw);
}

// ============================================================================
// Event Handlers
// ============================================================================

function setupEventHandlers() {
    // Sliders
    document.getElementById('particleCountSlider').addEventListener('input', (e) => {
        particleCount = Math.pow(2, parseInt(e.target.value));
        document.getElementById('particleCountText').textContent = `${particleCount} particles`;
    });
    
    document.getElementById('speciesCountSlider').addEventListener('input', (e) => {
        speciesCount = parseInt(e.target.value);
        document.getElementById('speciesCountText').textContent = `${speciesCount} particle types`;
    });
    
    document.getElementById('simulationWidthSlider').addEventListener('input', (e) => {
        const W = Math.round(e.target.value) * 32;
        simulationBox[0] = [-W, W];
        document.getElementById('simulationWidthText').textContent = `Width: ${2 * W}`;
    });
    
    document.getElementById('simulationHeightSlider').addEventListener('input', (e) => {
        const H = Math.round(e.target.value) * 32;
        simulationBox[1] = [-H, H];
        document.getElementById('simulationHeightText').textContent = `Height: ${2 * H}`;
    });
    
    document.getElementById('frictionSlider').addEventListener('input', (e) => {
        friction = parseFloat(e.target.value);
        document.getElementById('frictionText').textContent = `Friction: ${friction}`;
    });
    
    document.getElementById('centralForceSlider').addEventListener('input', (e) => {
        centralForce = parseFloat(e.target.value) / 10.0;
        document.getElementById('centralForceText').textContent = `Central force: ${centralForce}`;
    });
    
    document.getElementById('symmetricForces').addEventListener('change', (e) => {
        symmetricForces = e.target.checked;
    });
    
    document.getElementById('loopingBorders').addEventListener('change', (e) => {
        loopingBorders = e.target.checked;
    });
    
    // Buttons
    document.getElementById('pauseButton').addEventListener('click', (e) => {
        paused = !paused;
        e.target.textContent = paused ? 'Continue' : 'Pause';
    });
    
    document.getElementById('centerViewButton').addEventListener('click', centerView);
    
    document.getElementById('restartButton').addEventListener('click', () => {
        const seed = randomSeed();
        const systemData = generateSystem(seed);
        loadSystem(systemData);
    });
    
    document.getElementById('randomizeButton').addEventListener('click', () => {
        const seed = randomSeed();
        const systemData = generateSystem(seed);
        loadSystem(systemData);
    });
    
    // Mouse events
    canvas.addEventListener('wheel', (e) => {
        const factor = Math.pow(1.25, e.deltaY / 120);
        cameraExtentXTarget *= factor;
        
        zoomAnchor = [
            2.0 * e.x / canvas.width - 1.0,
            1.0 - 2.0 * e.y / canvas.height,
        ];
        
        e.preventDefault();
    }, false);
    
    canvas.addEventListener('mousedown', (e) => {
        if (e.button == 0) {
            actionPoint = [e.clientX, e.clientY];
            actionDrag = [0.0, 0.0];
        }
        if (e.button == 2) {
            mouseDrag = [e.clientX, e.clientY];
        }
        e.preventDefault();
    }, false);
    
    canvas.addEventListener('mouseup', (e) => {
        if (e.button == 0) {
            actionPoint = null;
            actionDrag = null;
        }
        if (e.button == 2) {
            mouseDrag = null;
        }
        e.preventDefault();
    }, false);
    
    canvas.addEventListener('contextmenu', (e) => {
        e.preventDefault();
    }, false);
    
    canvas.addEventListener('mousemove', (e) => {
        if (actionPoint) {
            actionDrag = [e.clientX - actionPoint[0], e.clientY - actionPoint[1]];
            actionPoint = [e.clientX, e.clientY];
        }
        
        if (mouseDrag) {
            const delta = [e.clientX - mouseDrag[0], e.clientY - mouseDrag[1]];
            cameraCenter[0] -= delta[0] / canvas.width * cameraExtentX * 2.0;
            cameraCenter[1] += delta[1] / canvas.height * cameraExtentY * 2.0;
            mouseDrag = [e.clientX, e.clientY];
        }
        
        e.preventDefault();
    }, false);
    
    // Keyboard
    window.addEventListener('keydown', (e) => {
        if (e.key == ' ') {
            document.getElementById('pauseButton').click();
            e.preventDefault();
        }
        if (e.key == 'c') {
            centerView();
            e.preventDefault();
        }
        if (e.key == 's' || e.key == 'S') {
            toolsPanelShown = !toolsPanelShown;
            e.preventDefault();
        }
        if (e.key == 'd' || e.key == 'D') {
            debugPanelShown = !debugPanelShown;
            e.preventDefault();
        }
    }, false);
    
    window.addEventListener('resize', resize);
}

// ============================================================================
// Initialization
// ============================================================================

async function init() {
    console.log('Initializing WebGPU Particle Life...');
    
    if (!await initWebGPU()) {
        document.getElementById('loading').innerHTML = '<div style="color: red;">WebGPU not supported!</div>';
        return;
    }
    
    await initResources();
    createPipelines();
    resize();
    
    // Generate initial system
    const seed = randomSeed();
    const systemData = generateSystem(seed);
    loadSystem(systemData);
    
    centerView();
    
    // Hide loading, show UI
    document.getElementById('loading').classList.add('hidden');
    document.getElementById('toolsPanel').classList.remove('hidden');
    
    setupEventHandlers();
    
    console.log('WebGPU initialized! Starting render loop...');
    requestAnimationFrame(redraw);
}

init();
    </script>
</body>
</html>

