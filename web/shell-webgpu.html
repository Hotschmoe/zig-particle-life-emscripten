<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Life - Zig WebAssembly + WebGPU</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
        }
        
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: #000;
        }
        
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(40, 40, 40, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #444;
            min-width: 300px;
            z-index: 1000;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        h1 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #4CAF50;
        }
        
        .control-group {
            margin-bottom: 12px;
        }
        
        label {
            display: block;
            font-size: 12px;
            margin-bottom: 4px;
            color: #aaa;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 4px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            margin-top: 8px;
            background: #4CAF50;
            border: none;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:active {
            background: #3d8b40;
        }
        
        .value-display {
            display: inline-block;
            color: #4CAF50;
            font-weight: bold;
            font-size: 12px;
        }
        
        #stats {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(40, 40, 40, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            border: 2px solid #444;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 1000;
        }
        
        .stat-row {
            margin-bottom: 4px;
        }
        
        .stat-label {
            color: #888;
        }
        
        .stat-value {
            color: #4CAF50;
            font-weight: bold;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #4CAF50;
            text-align: center;
        }
        
        .hidden {
            display: none;
        }
        
        #toggleControls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1001;
            background: rgba(40, 40, 40, 0.95);
            padding: 8px 16px;
            border-radius: 6px;
            border: 2px solid #444;
            cursor: pointer;
        }
        
        .error {
            color: #ff5555;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="loading">
        <div>Loading WebAssembly + WebGPU...</div>
        <div style="font-size: 14px; margin-top: 10px; color: #888;">Please wait</div>
    </div>
    
    <button id="toggleControls" class="hidden">‚öôÔ∏è Toggle Controls</button>
    
    <div id="controls" class="hidden">
        <h1>üåå Particle Life Simulator (WebGPU)</h1>
        
        <div class="control-group">
            <label>Particles: <span class="value-display" id="particleCountValue">16384</span></label>
            <input type="range" id="particleCount" min="10" max="16" value="14" step="1">
        </div>
        
        <div class="control-group">
            <label>Species: <span class="value-display" id="speciesCountValue">6</span></label>
            <input type="range" id="speciesCount" min="2" max="12" value="6" step="1">
        </div>
        
        <div class="control-group">
            <label>Friction: <span class="value-display" id="frictionValue">10.0</span></label>
            <input type="range" id="friction" min="0" max="50" value="10" step="0.5">
        </div>
        
        <div class="control-group">
            <label>Central Force: <span class="value-display" id="centralForceValue">0.0</span></label>
            <input type="range" id="centralForce" min="0" max="10" value="0" step="0.1">
        </div>
        
        <button id="restart">üîÑ Restart</button>
        <button id="randomize">üé≤ Randomize</button>
        <button id="togglePause">‚è∏Ô∏è Pause</button>
        
        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #555; font-size: 11px; color: #888;">
            <div>üñ±Ô∏è <strong>Left Click + Drag:</strong> Push particles</div>
            <div>üîç <strong>Mouse Wheel:</strong> Zoom in/out</div>
            <div>‚å®Ô∏è <strong>S:</strong> Toggle controls</div>
        </div>
    </div>
    
    <div id="stats" class="hidden">
        <div class="stat-row">
            <span class="stat-label">FPS:</span>
            <span class="stat-value" id="fps">60</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Particles:</span>
            <span class="stat-value" id="particleCountStat">16384</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Species:</span>
            <span class="stat-value" id="speciesCountStat">6</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Renderer:</span>
            <span class="stat-value">WebGPU</span>
        </div>
    </div>
    
    {{{ SCRIPT }}}
    
    <script>
        // Module will be defined by emscripten's generated code
        var Module = {
            onRuntimeInitialized: function() {
                main();
            },
            print: function(text) {
                console.log(text);
            },
            printErr: function(text) {
                console.error(text);
            },
        };
        
        // Canvas and WebGPU state
        const canvas = document.getElementById('canvas');
        let device, context, format;
        let particleBuffer, speciesBuffer, uniformBuffer;
        let renderPipeline, renderBindGroup;
        
        // Simulation state
        let isRunning = false;
        let isPaused = false;
        let particleCount = 16384;
        let speciesCount = 6;
        let lastTime = performance.now();
        let frameCount = 0;
        let fpsUpdateTime = 0;
        let controlsVisible = true;
        
        // Camera
        let cameraX = 0;
        let cameraY = 0;
        let cameraZoom = 1.0;
        
        // Mouse interaction
        let mouseX = 0;
        let mouseY = 0;
        let mouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // WASM Functions
        let initParticleSystem;
        let generateRandomSystem;
        let simulationStep;
        let getParticleCount;
        let getParticleData;
        let getSpeciesData;
        let setSimulationBounds;
        let setFriction;
        let setCentralForce;
        let setLoopingBorders;
        let setActionPoint;
        let clearActionPoint;
        
        // WebGPU Shaders
        const particleVertexShader = `
struct Particle {
    x: f32,
    y: f32,
    vx: f32,
    vy: f32,
    species: u32,
}

struct Species {
    r: f32,
    g: f32,
    b: f32,
    a: f32,
}

struct Uniforms {
    viewProjection: mat4x4<f32>,
    particleSize: f32,
    padding: vec3<f32>,
}

@group(0) @binding(0) var<storage, read> particles: array<Particle>;
@group(0) @binding(1) var<storage, read> species: array<Species>;
@group(0) @binding(2) var<uniform> uniforms: Uniforms;

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) color: vec4<f32>,
    @location(1) uv: vec2<f32>,
}

@vertex
fn vertexMain(@builtin(vertex_index) vertexIndex: u32, @builtin(instance_index) instanceIndex: u32) -> VertexOutput {
    // Quad vertices (two triangles)
    var positions = array<vec2<f32>, 6>(
        vec2<f32>(-1.0, -1.0),
        vec2<f32>(1.0, -1.0),
        vec2<f32>(-1.0, 1.0),
        vec2<f32>(-1.0, 1.0),
        vec2<f32>(1.0, -1.0),
        vec2<f32>(1.0, 1.0)
    );
    
    let quadPos = positions[vertexIndex];
    let particle = particles[instanceIndex];
    let speciesData = species[particle.species];
    
    // Calculate world position
    let worldPos = vec2<f32>(particle.x, particle.y);
    let offset = quadPos * uniforms.particleSize;
    let finalPos = worldPos + offset;
    
    var output: VertexOutput;
    output.position = uniforms.viewProjection * vec4<f32>(finalPos, 0.0, 1.0);
    output.color = vec4<f32>(speciesData.r, speciesData.g, speciesData.b, speciesData.a);
    output.uv = quadPos;
    
    return output;
}

@fragment
fn fragmentMain(input: VertexOutput) -> @location(0) vec4<f32> {
    // Circular particle with soft edge
    let dist = length(input.uv);
    if (dist > 1.0) {
        discard;
    }
    
    // Soft glow effect
    let alpha = smoothstep(1.0, 0.3, dist);
    let brightness = smoothstep(1.0, 0.0, dist) * 0.5 + 0.5;
    
    return vec4<f32>(input.color.rgb * brightness, input.color.a * alpha);
}
`;
        
        // Initialize canvas size
        function resizeCanvas() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            
            if (context) {
                context.configure({
                    device: device,
                    format: format,
                    alphaMode: 'premultiplied',
                });
            }
        }
        
        window.addEventListener('resize', resizeCanvas);
        
        // Check WebGPU support
        async function checkWebGPUSupport() {
            if (!navigator.gpu) {
                document.getElementById('loading').innerHTML = `
                    <div class="error">WebGPU Not Supported</div>
                    <div style="font-size: 14px; margin-top: 10px;">
                        Your browser doesn't support WebGPU.<br>
                        Try Chrome 113+ or Edge 113+
                    </div>
                `;
                return false;
            }
            return true;
        }
        
        // Initialize WebGPU
        async function initWebGPU() {
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                throw new Error('Failed to get GPU adapter');
            }
            
            device = await adapter.requestDevice();
            context = canvas.getContext('webgpu');
            format = navigator.gpu.getPreferredCanvasFormat();
            
            resizeCanvas();
            
            // Create shader module
            const shaderModule = device.createShaderModule({
                label: 'Particle Shader',
                code: particleVertexShader,
            });
            
            // Create render pipeline
            renderPipeline = device.createRenderPipeline({
                label: 'Particle Render Pipeline',
                layout: 'auto',
                vertex: {
                    module: shaderModule,
                    entryPoint: 'vertexMain',
                },
                fragment: {
                    module: shaderModule,
                    entryPoint: 'fragmentMain',
                    targets: [{
                        format: format,
                        blend: {
                            color: {
                                srcFactor: 'src-alpha',
                                dstFactor: 'one',
                                operation: 'add',
                            },
                            alpha: {
                                srcFactor: 'one',
                                dstFactor: 'one',
                                operation: 'add',
                            },
                        },
                    }],
                },
                primitive: {
                    topology: 'triangle-list',
                },
            });
            
            console.log('WebGPU initialized successfully');
        }
        
        function initWASM() {
            // Get function references from WASM module
            initParticleSystem = Module.cwrap('initParticleSystem', 'number', ['number', 'number', 'number']);
            generateRandomSystem = Module.cwrap('generateRandomSystem', null, ['number']);
            simulationStep = Module.cwrap('simulationStep', null, ['number']);
            getParticleCount = Module.cwrap('getParticleCount', 'number', []);
            getParticleData = Module.cwrap('getParticleData', 'number', []);
            getSpeciesData = Module.cwrap('getSpeciesData', 'number', []);
            setSimulationBounds = Module.cwrap('setSimulationBounds', null, ['number', 'number', 'number', 'number']);
            setFriction = Module.cwrap('setFriction', null, ['number']);
            setCentralForce = Module.cwrap('setCentralForce', null, ['number']);
            setLoopingBorders = Module.cwrap('setLoopingBorders', null, ['number']);
            setActionPoint = Module.cwrap('setActionPoint', null, ['number', 'number', 'number', 'number', 'number', 'number']);
            clearActionPoint = Module.cwrap('clearActionPoint', null, []);
        }
        
        function createBuffers() {
            // Create particle buffer
            const particleDataSize = particleCount * 20; // 5 floats per particle (x, y, vx, vy, species as f32)
            particleBuffer = device.createBuffer({
                label: 'Particle Buffer',
                size: particleDataSize,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            
            // Create species buffer
            const speciesDataSize = speciesCount * 16; // 4 floats per species
            speciesBuffer = device.createBuffer({
                label: 'Species Buffer',
                size: speciesDataSize,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            
            // Create uniform buffer (view-projection matrix + particle size)
            // WebGPU requires 96 bytes due to alignment rules (mat4x4 + vec4)
            uniformBuffer = device.createBuffer({
                label: 'Uniform Buffer',
                size: 96, // mat4x4 (64 bytes) + vec4 (16 bytes) for proper alignment
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            
            // Create bind group
            renderBindGroup = device.createBindGroup({
                label: 'Particle Render Bind Group',
                layout: renderPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: particleBuffer } },
                    { binding: 1, resource: { buffer: speciesBuffer } },
                    { binding: 2, resource: { buffer: uniformBuffer } },
                ],
            });
        }
        
        function initSimulation() {
            const seed = Math.floor(Math.random() * 0xFFFFFFFF);
            const success = initParticleSystem(particleCount, speciesCount, seed);
            
            if (!success) {
                console.error('Failed to initialize particle system');
                return false;
            }
            
            generateRandomSystem(0); // 0 = asymmetric forces
            
            // Set simulation bounds
            const aspect = canvas.width / canvas.height;
            const height = 288;
            const width = height * aspect;
            setSimulationBounds(-width, width, -height, height);
            
            // Recreate GPU buffers
            createBuffers();
            
            updateUIValues();
            return true;
        }
        
        function updateUIValues() {
            document.getElementById('particleCountValue').textContent = particleCount;
            document.getElementById('speciesCountValue').textContent = speciesCount;
            document.getElementById('particleCountStat').textContent = particleCount;
            document.getElementById('speciesCountStat').textContent = speciesCount;
        }
        
        function updateGPUBuffers() {
            // Get particle data from WASM memory
            const particleDataPtr = getParticleData();
            const particleDataView = new Float32Array(
                Module.HEAPU8.buffer,
                particleDataPtr,
                particleCount * 5
            );
            
            // Get species data from WASM memory
            const speciesDataPtr = getSpeciesData();
            const speciesDataView = new Float32Array(
                Module.HEAPU8.buffer,
                speciesDataPtr,
                speciesCount * 4
            );
            
            // Copy to GPU buffers
            device.queue.writeBuffer(particleBuffer, 0, particleDataView);
            device.queue.writeBuffer(speciesBuffer, 0, speciesDataView);
        }
        
        function updateUniforms() {
            // Create view-projection matrix
            const aspect = canvas.width / canvas.height;
            const height = 288;
            const width = height * aspect;
            
            // Orthographic projection
            const left = (-width - cameraX) * cameraZoom;
            const right = (width - cameraX) * cameraZoom;
            const bottom = (-height - cameraY) * cameraZoom;
            const top = (height - cameraY) * cameraZoom;
            const near = -1;
            const far = 1;
            
            const matrix = new Float32Array(16);
            matrix[0] = 2 / (right - left);
            matrix[5] = 2 / (top - bottom);
            matrix[10] = -2 / (far - near);
            matrix[12] = -(right + left) / (right - left);
            matrix[13] = -(top + bottom) / (top - bottom);
            matrix[14] = -(far + near) / (far - near);
            matrix[15] = 1;
            
            // Particle size in world units
            const particleSize = 3.0 * cameraZoom;
            
            // Create uniform data (96 bytes = 24 floats)
            const uniformData = new Float32Array(24); // 16 for matrix + 4 for vec4 (size+padding)
            uniformData.set(matrix, 0);
            uniformData[16] = particleSize;
            // uniformData[17-23] remain 0 (padding)
            
            device.queue.writeBuffer(uniformBuffer, 0, uniformData);
        }
        
        function render() {
            const encoder = device.createCommandEncoder({ label: 'Render Encoder' });
            const textureView = context.getCurrentTexture().createView();
            
            const renderPass = encoder.beginRenderPass({
                label: 'Particle Render Pass',
                colorAttachments: [{
                    view: textureView,
                    loadOp: 'clear',
                    clearValue: { r: 0, g: 0, b: 0, a: 1 },
                    storeOp: 'store',
                }],
            });
            
            renderPass.setPipeline(renderPipeline);
            renderPass.setBindGroup(0, renderBindGroup);
            renderPass.draw(6, particleCount); // 6 vertices per particle (2 triangles)
            renderPass.end();
            
            device.queue.submit([encoder.finish()]);
        }
        
        function animate() {
            if (!isRunning) return;
            
            const currentTime = performance.now();
            const dt = Math.min((currentTime - lastTime) / 1000, 0.05); // Cap at 50ms
            lastTime = currentTime;
            
            // Update FPS counter
            frameCount++;
            if (currentTime - fpsUpdateTime > 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                fpsUpdateTime = currentTime;
            }
            
            // Run simulation step
            if (!isPaused) {
                // Set mouse interaction
                if (mouseDown) {
                    const dx = mouseX - lastMouseX;
                    const dy = mouseY - lastMouseY;
                    
                    // Convert screen to world coordinates
                    const aspect = canvas.width / canvas.height;
                    const height = 288;
                    const width = height * aspect;
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const scale = Math.min(canvas.width, canvas.height) / 600 * cameraZoom;
                    
                    const worldX = cameraX + (mouseX - centerX) / scale;
                    const worldY = cameraY - (mouseY - centerY) / scale;
                    const worldDx = dx / scale;
                    const worldDy = -dy / scale;
                    
                    setActionPoint(worldX, worldY, worldDx * 50, worldDy * 50, 20.0, 50.0);
                } else {
                    clearActionPoint();
                }
                
                simulationStep(dt);
                updateGPUBuffers();
            }
            
            // Update camera and render
            updateUniforms();
            render();
            
            requestAnimationFrame(animate);
        }
        
        // Event handlers
        function setupEventHandlers() {
            document.getElementById('particleCount').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                particleCount = Math.pow(2, value);
                document.getElementById('particleCountValue').textContent = particleCount;
            });
            
            document.getElementById('speciesCount').addEventListener('input', (e) => {
                speciesCount = parseInt(e.target.value);
                document.getElementById('speciesCountValue').textContent = speciesCount;
            });
            
            document.getElementById('friction').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                setFriction(value);
                document.getElementById('frictionValue').textContent = value.toFixed(1);
            });
            
            document.getElementById('centralForce').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                setCentralForce(value);
                document.getElementById('centralForceValue').textContent = value.toFixed(1);
            });
            
            document.getElementById('restart').addEventListener('click', () => {
                initSimulation();
            });
            
            document.getElementById('randomize').addEventListener('click', () => {
                initSimulation();
            });
            
            document.getElementById('togglePause').addEventListener('click', (e) => {
                isPaused = !isPaused;
                e.target.textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
            });
            
            document.getElementById('toggleControls').addEventListener('click', () => {
                controlsVisible = !controlsVisible;
                document.getElementById('controls').style.display = controlsVisible ? 'block' : 'none';
            });
            
            // Mouse events
            canvas.addEventListener('mousedown', (e) => {
                mouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
                lastMouseX = mouseX;
                lastMouseY = mouseY;
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (mouseDown) {
                    lastMouseX = mouseX;
                    lastMouseY = mouseY;
                }
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            canvas.addEventListener('mouseup', () => {
                mouseDown = false;
            });
            
            canvas.addEventListener('mouseleave', () => {
                mouseDown = false;
            });
            
            // Wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
                cameraZoom *= zoomFactor;
                cameraZoom = Math.max(0.1, Math.min(5, cameraZoom));
            });
            
            // Keyboard
            document.addEventListener('keydown', (e) => {
                if (e.key === 's' || e.key === 'S') {
                    controlsVisible = !controlsVisible;
                    document.getElementById('controls').style.display = controlsVisible ? 'block' : 'none';
                }
                if (e.key === ' ') {
                    e.preventDefault();
                    document.getElementById('togglePause').click();
                }
            });
        }
        
        // Main initialization
        async function main() {
            console.log('Starting initialization...');
            
            // Check WebGPU support
            if (!await checkWebGPUSupport()) {
                return;
            }
            
            try {
                // Initialize WebGPU
                await initWebGPU();
                
                // Initialize WASM
                initWASM();
                setupEventHandlers();
                
                // Initialize simulation
                if (!initSimulation()) return;
                
                // Hide loading, show UI
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('controls').classList.remove('hidden');
                document.getElementById('stats').classList.remove('hidden');
                document.getElementById('toggleControls').classList.remove('hidden');
                
                // Start animation loop
                isRunning = true;
                lastTime = performance.now();
                fpsUpdateTime = lastTime;
                
                animate();
                
                console.log('Initialization complete!');
            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('loading').innerHTML = `
                    <div class="error">Initialization Failed</div>
                    <div style="font-size: 14px; margin-top: 10px; color: #888;">
                        ${error.message}
                    </div>
                `;
            }
        }
    </script>
</body>
</html>

