# Build Notes - Zig Particle Life with Emscripten

## Implementation Approach

This project uses a **two-step build process** to compile Zig code to WebAssembly using Emscripten:

### 1. Zig → Static Library
Zig compiles the code to a static library (`.a` file) targeting `wasm32-emscripten`.

### 2. Emscripten Linker → WebAssembly
The `emcc` command links the static library into WebAssembly and generates the HTML/JS glue code.

## Why This Approach?

The Zig standard library doesn't fully support the `wasm32-emscripten` target. Direct compilation fails because:
- `std.Thread` doesn't support emscripten
- `std.posix` has missing functions for emscripten
- `std.heap.GeneralPurposeAllocator` uses unsupported OS features

## Solution

We use a **freestanding approach**:

1. **Custom allocator**: Simple bump allocator instead of GPA
2. **No std dependencies**: Avoid `std.Thread`, `std.posix`, etc.
3. **Manual memory management**: Direct pointer arithmetic
4. **Custom math functions**: Inline implementations instead of `std.math`

## Build System (`build.zig`)

The build system detects the target architecture:

```zig
const is_wasm = target.result.cpu.arch == .wasm32;

if (is_wasm) {
    buildWeb(b, actual_target, optimize);
} else {
    buildNative(b, target, optimize);
}
```

### Web Build Steps

1. Build Zig code as static library with `linkLibC()`
2. Invoke `emcc` with proper flags:
   - Export WASM functions
   - Configure memory settings
   - Use custom shell template (`web/shell.html`)
   - Apply optimization flags

### Exported Functions

All functions exported to JavaScript (via `export` keyword):

- `initParticleSystem(count, species, seed)` - Initialize simulation
- `generateRandomSystem(symmetric)` - Generate forces and particles
- `simulationStep(dt)` - Run one simulation frame
- `getParticleData()` - Get particle array pointer
- `getSpeciesData()` - Get species colors pointer
- `setSimulationBounds(...)` - Configure world bounds
- `setFriction(...)`, `setCentralForce(...)` - Tweak parameters
- `setActionPoint(...)` - Apply user interaction forces
- `clearActionPoint()` - Stop user interaction

## Memory Layout

The simulation uses a fixed-size heap (64MB) with a bump allocator:

```zig
const HEAP_SIZE = 64 * 1024 * 1024; // 64MB
var heap_memory: [HEAP_SIZE]u8 align(16) = undefined;
```

All allocations are linear and never freed. When restarting the simulation, we call `resetHeap()` to reclaim all memory.

### Memory Breakdown

Total WASM initial memory: **128MB** (134,217,728 bytes)
- **64MB** - Particle simulation heap (our static array)
- **~5MB** - Stack size (for function calls and local variables)
- **~3MB** - Compiled code and static data
- **~56MB** - Runtime overhead and growth buffer

The linker needs at least ~72MB to link successfully, so we allocate 128MB to have plenty of room.

## File Structure

```
build.zig           - Build configuration with emcc integration
src/main.zig        - Freestanding particle simulator
web/shell.html      - Emscripten HTML template
web/index.html      - Original WebGPU reference (for comparison)
web/particle-life.* - Generated by build (HTML, WASM, JS)
```

## Build Command

### Automatic Setup (Windows Only)

On Windows, emsdk is automatically downloaded and installed:

```bash
# No --sysroot needed! Just run:
zig build -Dtarget=wasm32-emscripten
```

The build script will:
1. Check if `emsdk/` exists in the project directory
2. If not, clone the emsdk repository via git
3. Run `emsdk.bat install latest`
4. Run `emsdk.bat activate latest`
5. Use the local emsdk automatically

The `emsdk/` directory is gitignored and stays local to your machine.

### Manual Setup (Linux/macOS)

For non-Windows platforms, you need to provide the `--sysroot` flag:

```bash
zig build -Dtarget=wasm32-emscripten --sysroot ~/emsdk/upstream/emscripten
```

**TODO:** Add automatic setup for Linux and macOS in a future update.

The `--sysroot` flag tells Zig where to find Emscripten's system headers.

## Emscripten Flags Used

- `-sEXPORTED_FUNCTIONS=...` - List of functions to export
- `-sEXPORTED_RUNTIME_METHODS=ccall,cwrap` - JS helpers for calling WASM
- `-sALLOW_MEMORY_GROWTH=1` - Allow heap to grow if needed
- `-sINITIAL_MEMORY=134217728` - Start with 128MB (64MB heap + code + stack + runtime overhead)
- `-sSTACK_SIZE=5242880` - 5MB stack size
- `-sENVIRONMENT=web` - Target web browsers only
- `-sMODULARIZE=1` - Generate as ES6 module
- `-sEXPORT_NAME=createParticleLifeModule` - Module factory function name
- `-Oz --closure 1` - Maximum size optimization (ReleaseSmall mode)

**Note:** We don't need `-sUSE_OFFSET_CONVERTER` because we use a custom bump allocator that doesn't rely on `@returnAddress` from the standard library.

## Comparison with Reference Implementations

This approach is similar to other Zig+Emscripten projects:

1. **Sokol example**: Uses a helper library (`sokol.emLinkStep`) to wrap emcc
2. **15game example**: Manually invokes emcc (our approach)

We chose the **manual approach** because:
- No extra dependencies
- Full control over emcc flags
- Simpler to understand and customize
- Easier to debug

## Testing

1. Build the WASM:
   ```bash
   zig build -Dtarget=wasm32-emscripten --sysroot [emsdk-path]
   ```

2. Serve locally:
   ```bash
   python -m http.server 8000 --directory web
   ```

3. Open browser:
   ```
   http://localhost:8000/particle-life.html
   ```

## Performance

- **Binary size**: ~50-100KB (gzipped) with ReleaseSmall
- **Performance**: 16,384 particles @ 60 FPS on modern hardware
- **Memory**: 128MB WASM initial memory (64MB heap + runtime)
- **Allocation**: Fixed bump allocator, no garbage collection, instant resets

## Automatic Emsdk Setup (Windows)

A key feature of this project is **automatic Emscripten installation** on Windows.

### How It Works

The build script (`build.zig`) contains these functions:

1. **`checkEmsdkExists()`** - Checks if `emsdk/` directory exists
2. **`setupEmsdk()`** - Downloads and installs emsdk (Windows only)
3. **`getEmscriptenPath()`** - Returns path to emscripten, auto-installing if needed

### Installation Flow

```
User runs: zig build -Dtarget=wasm32-emscripten
     ↓
Check if emsdk/ exists?
     ↓ No
Clone emsdk repo (git clone)
     ↓
Run: emsdk.bat install latest
     ↓
Run: emsdk.bat activate latest
     ↓
Build project with local emsdk
```

### Why Windows Only (For Now)?

The automatic setup uses `.bat` files and Windows-specific paths. To support Linux/macOS, we need:

- Detect shell scripts vs batch files
- Handle different path separators
- Test on those platforms
- Ensure git is available

**TODO:** Add Linux/macOS support in a future update.

### Benefits

- **Zero manual setup** for Windows users
- **Project-local emsdk** (each project has its own)
- **Version controlled** via gitignore (not committed)
- **Consistent builds** across machines

## Future Improvements

- [ ] Add WASM SIMD support for vectorized force calculations
- [ ] Implement threading with SharedArrayBuffer
- [ ] Add compression (Brotli) to reduce binary size further
- [ ] Profile and optimize hot loops (force computation)
- [ ] Add support for custom force rules via JSON
- [ ] **Add automatic emsdk setup for Linux and macOS**

