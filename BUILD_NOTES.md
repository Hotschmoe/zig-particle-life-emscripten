# Build Notes - Zig Particle Life with Emscripten

## Implementation Approach

This project uses a **two-step build process** to compile Zig code to WebAssembly using Emscripten:

### 1. Zig → Static Library
Zig compiles the code to a static library (`.a` file) targeting `wasm32-emscripten`.

### 2. Emscripten Linker → WebAssembly
The `emcc` command links the static library into WebAssembly and generates the HTML/JS glue code.

## Why This Approach?

The Zig standard library doesn't fully support the `wasm32-emscripten` target. Direct compilation fails because:
- `std.Thread` doesn't support emscripten
- `std.posix` has missing functions for emscripten
- `std.heap.GeneralPurposeAllocator` uses unsupported OS features

## Solution

We use a **freestanding approach**:

1. **Custom allocator**: Simple bump allocator instead of GPA
2. **No std dependencies**: Avoid `std.Thread`, `std.posix`, etc.
3. **Manual memory management**: Direct pointer arithmetic
4. **Custom math functions**: Inline implementations instead of `std.math`

## Build System (`build.zig`)

The build system detects the target architecture:

```zig
const is_wasm = target.result.cpu.arch == .wasm32;

if (is_wasm) {
    buildWeb(b, actual_target, optimize);
} else {
    buildNative(b, target, optimize);
}
```

### Web Build Steps

1. Build Zig code as static library with `linkLibC()`
2. Invoke `emcc` with proper flags:
   - Export WASM functions
   - Configure memory settings
   - Use custom shell template (`web/shell.html`)
   - Apply optimization flags

### Exported Functions

All functions exported to JavaScript (via `export` keyword):

- `initParticleSystem(count, species, seed)` - Initialize simulation
- `generateRandomSystem(symmetric)` - Generate forces and particles
- `simulationStep(dt)` - Run one simulation frame
- `getParticleData()` - Get particle array pointer
- `getSpeciesData()` - Get species colors pointer
- `setSimulationBounds(...)` - Configure world bounds
- `setFriction(...)`, `setCentralForce(...)` - Tweak parameters
- `setActionPoint(...)` - Apply user interaction forces
- `clearActionPoint()` - Stop user interaction

## Memory Layout

The simulation uses a fixed-size heap (64MB) with a bump allocator:

```zig
const HEAP_SIZE = 64 * 1024 * 1024; // 64MB
var heap_memory: [HEAP_SIZE]u8 align(16) = undefined;
```

All allocations are linear and never freed. When restarting the simulation, we call `resetHeap()` to reclaim all memory.

## File Structure

```
build.zig           - Build configuration with emcc integration
src/main.zig        - Freestanding particle simulator
web/shell.html      - Emscripten HTML template
web/index.html      - Original WebGPU reference (for comparison)
web/particle-life.* - Generated by build (HTML, WASM, JS)
```

## Build Command

**Windows:**
```bash
zig build -Dtarget=wasm32-emscripten --sysroot C:/emsdk/upstream/emscripten
```

**Linux/macOS:**
```bash
zig build -Dtarget=wasm32-emscripten --sysroot ~/emsdk/upstream/emscripten
```

The `--sysroot` flag tells Zig where to find Emscripten's system headers.

## Emscripten Flags Used

- `-sEXPORTED_FUNCTIONS=...` - List of functions to export
- `-sEXPORTED_RUNTIME_METHODS=ccall,cwrap` - JS helpers for calling WASM
- `-sALLOW_MEMORY_GROWTH=1` - Allow heap to grow if needed
- `-sINITIAL_MEMORY=67108864` - Start with 64MB
- `-sUSE_OFFSET_CONVERTER=1` - Required for `@returnAddress` in allocator
- `-sMODULARIZE=1` - Generate as ES6 module
- `-Oz --closure 1` - Maximum size optimization (ReleaseSmall mode)

## Comparison with Reference Implementations

This approach is similar to other Zig+Emscripten projects:

1. **Sokol example**: Uses a helper library (`sokol.emLinkStep`) to wrap emcc
2. **15game example**: Manually invokes emcc (our approach)

We chose the **manual approach** because:
- No extra dependencies
- Full control over emcc flags
- Simpler to understand and customize
- Easier to debug

## Testing

1. Build the WASM:
   ```bash
   zig build -Dtarget=wasm32-emscripten --sysroot [emsdk-path]
   ```

2. Serve locally:
   ```bash
   python -m http.server 8000 --directory web
   ```

3. Open browser:
   ```
   http://localhost:8000/particle-life.html
   ```

## Performance

- **Binary size**: ~50-100KB (gzipped) with ReleaseSmall
- **Performance**: 16,384 particles @ 60 FPS on modern hardware
- **Memory**: Fixed 64MB heap, no garbage collection

## Future Improvements

- [ ] Add WASM SIMD support for vectorized force calculations
- [ ] Implement threading with SharedArrayBuffer
- [ ] Add compression (Brotli) to reduce binary size further
- [ ] Profile and optimize hot loops (force computation)
- [ ] Add support for custom force rules via JSON

